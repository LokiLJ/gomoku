<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº”å­æ£‹åœ¨çº¿å¯¹æˆ˜</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 10px;
            color: #e0c068;
        }

        /* ä¿¡æ¯æ  */
        .info-bar {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .info-item {
            background: #16213e;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
        }

        .info-item.role-black { border-left: 4px solid #111; }
        .info-item.role-white { border-left: 4px solid #fff; }
        .info-item.role-spectator { border-left: 4px solid #888; }

        /* çŠ¶æ€æ¶ˆæ¯ */
        #status {
            font-size: 18px;
            margin-bottom: 15px;
            padding: 10px 20px;
            border-radius: 8px;
            background: #16213e;
            text-align: center;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #status.turn-black { border: 2px solid #555; }
        #status.turn-white { border: 2px solid #ddd; }
        #status.winner { background: #2d5016; border: 2px solid #4caf50; }
        #status.waiting { border: 2px solid #e0c068; }

        /* æ£‹ç›˜å®¹å™¨ */
        .board-container {
            position: relative;
            margin-bottom: 20px;
        }

        canvas {
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        /* æŒ‰é’® */
        .buttons {
            display: flex;
            gap: 12px;
        }

        button {
            padding: 10px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover { transform: translateY(-1px); }
        button:active { transform: translateY(0); }

        #resetBtn {
            background: #e0c068;
            color: #1a1a2e;
            font-weight: bold;
        }

        #resetBtn:hover { background: #f0d078; }

        /* è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .connection-dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 6px;
            vertical-align: middle;
        }

        .connection-dot.connected { background: #4caf50; }
        .connection-dot.disconnected { background: #f44336; }
        .connection-dot.connecting { background: #ff9800; animation: blink 1s infinite; }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* æœ€åè½å­æ ‡è®°çš„åŠ¨ç”» */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
    </style>
</head>
<body>
    <h1>â™Ÿ äº”å­æ£‹åœ¨çº¿å¯¹æˆ˜</h1>

    <div class="info-bar">
        <div class="info-item" id="roleInfo">è¿æ¥ä¸­...</div>
        <div class="info-item" id="onlineInfo">åœ¨çº¿: -</div>
        <div class="info-item">
            <span class="connection-dot connecting" id="connDot"></span>
            <span id="connText">è¿æ¥ä¸­</span>
        </div>
    </div>

    <div id="status" class="waiting">ç­‰å¾…è¿æ¥æœåŠ¡å™¨...</div>

    <div class="board-container">
        <canvas id="board" width="600" height="600"></canvas>
    </div>

    <div class="buttons">
        <button id="resetBtn" onclick="requestReset()">é‡æ–°å¼€å±€</button>
    </div>

    <script>
        // ============================================================
        // é…ç½®
        // ============================================================
        const BOARD_SIZE = 15;
        const CANVAS_SIZE = 600;
        const PADDING = 25;
        const CELL_SIZE = (CANVAS_SIZE - 2 * PADDING) / (BOARD_SIZE - 1);

        // ============================================================
        // æ¸¸æˆçŠ¶æ€
        // ============================================================
        let myColor = 0;       // 0=è§‚ä¼—, 1=é»‘, 2=ç™½
        let myRole = "";       // "black", "white", "spectator"
        let currentTurn = 1;
        let winner = 0;
        let gameStarted = false;
        let board = Array.from({length: 15}, () => Array(15).fill(0));
        let lastMove = null;   // {row, col} æœ€åä¸€æ­¥è½å­ä½ç½®
        let ws = null;
        let reconnectTimer = null;
        let reconnectDelay = 1000;

        // ============================================================
        // Canvas ç»˜åˆ¶
        // ============================================================
        const canvas = document.getElementById("board");
        const ctx = canvas.getContext("2d");

        function drawBoard() {
            // æ£‹ç›˜èƒŒæ™¯
            ctx.fillStyle = "#dcb35c";
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // ç”»ç½‘æ ¼çº¿
            ctx.strokeStyle = "#8b6914";
            ctx.lineWidth = 1;

            for (let i = 0; i < BOARD_SIZE; i++) {
                const pos = PADDING + i * CELL_SIZE;

                // æ¨ªçº¿
                ctx.beginPath();
                ctx.moveTo(PADDING, pos);
                ctx.lineTo(CANVAS_SIZE - PADDING, pos);
                ctx.stroke();

                // ç«–çº¿
                ctx.beginPath();
                ctx.moveTo(pos, PADDING);
                ctx.lineTo(pos, CANVAS_SIZE - PADDING);
                ctx.stroke();
            }

            // ç”»æ˜Ÿä½ï¼ˆå¤©å…ƒå’Œå››ä¸ªè§’æ˜Ÿï¼‰
            const starPoints = [
                [3, 3], [3, 11], [11, 3], [11, 11], [7, 7]
            ];
            ctx.fillStyle = "#8b6914";
            for (const [r, c] of starPoints) {
                const x = PADDING + c * CELL_SIZE;
                const y = PADDING + r * CELL_SIZE;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }

            // ç”»æ£‹å­
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] !== 0) {
                        drawStone(r, c, board[r][c]);
                    }
                }
            }

            // ç”»æœ€åè½å­æ ‡è®°
            if (lastMove) {
                const x = PADDING + lastMove.col * CELL_SIZE;
                const y = PADDING + lastMove.row * CELL_SIZE;
                ctx.strokeStyle = lastMove.color === 1 ? "#fff" : "#000";
                ctx.lineWidth = 2;
                const markSize = 6;
                ctx.beginPath();
                ctx.moveTo(x - markSize, y);
                ctx.lineTo(x + markSize, y);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x, y - markSize);
                ctx.lineTo(x, y + markSize);
                ctx.stroke();
            }
        }

        function drawStone(row, col, color) {
            const x = PADDING + col * CELL_SIZE;
            const y = PADDING + row * CELL_SIZE;
            const radius = CELL_SIZE * 0.43;

            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);

            if (color === 1) {
                // é»‘å­ - å¸¦æ¸å˜
                const grad = ctx.createRadialGradient(x - 3, y - 3, 2, x, y, radius);
                grad.addColorStop(0, "#555");
                grad.addColorStop(1, "#000");
                ctx.fillStyle = grad;
            } else {
                // ç™½å­ - å¸¦æ¸å˜
                const grad = ctx.createRadialGradient(x - 3, y - 3, 2, x, y, radius);
                grad.addColorStop(0, "#fff");
                grad.addColorStop(1, "#ccc");
                ctx.fillStyle = grad;
            }

            ctx.fill();
            ctx.strokeStyle = color === 1 ? "#000" : "#999";
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // ============================================================
        // ç‚¹å‡»å¤„ç†
        // ============================================================
        canvas.addEventListener("click", (e) => {
            if (myColor === 0) return;      // è§‚ä¼—ä¸èƒ½ä¸‹
            if (winner !== 0) return;       // æ¸¸æˆå·²ç»“æŸ
            if (!gameStarted) return;       // æ¸¸æˆæœªå¼€å§‹
            if (currentTurn !== myColor) return; // ä¸æ˜¯ä½ çš„å›åˆ

            const rect = canvas.getBoundingClientRect();
            const scaleX = CANVAS_SIZE / rect.width;
            const scaleY = CANVAS_SIZE / rect.height;
            const mx = (e.clientX - rect.left) * scaleX;
            const my = (e.clientY - rect.top) * scaleY;

            const col = Math.round((mx - PADDING) / CELL_SIZE);
            const row = Math.round((my - PADDING) / CELL_SIZE);

            if (row < 0 || row >= BOARD_SIZE || col < 0 || col >= BOARD_SIZE) return;
            if (board[row][col] !== 0) return;

            // å‘é€è½å­è¯·æ±‚
            ws.send(JSON.stringify({
                type: "move",
                row: row,
                col: col,
            }));
        });

        // é¼ æ ‡æ‚¬åœæ•ˆæœ
        canvas.addEventListener("mousemove", (e) => {
            if (myColor === 0 || winner !== 0 || !gameStarted || currentTurn !== myColor) {
                canvas.style.cursor = "default";
                drawBoard(); // æ¸…é™¤ä¹‹å‰çš„æ‚¬åœæ•ˆæœ
                return;
            }

            const rect = canvas.getBoundingClientRect();
            const scaleX = CANVAS_SIZE / rect.width;
            const scaleY = CANVAS_SIZE / rect.height;
            const mx = (e.clientX - rect.left) * scaleX;
            const my = (e.clientY - rect.top) * scaleY;

            const col = Math.round((mx - PADDING) / CELL_SIZE);
            const row = Math.round((my - PADDING) / CELL_SIZE);

            drawBoard(); // é‡ç»˜æ¸…é™¤ä¸Šä¸€æ¬¡çš„æ‚¬åœ

            if (row >= 0 && row < BOARD_SIZE && col >= 0 && col < BOARD_SIZE && board[row][col] === 0) {
                canvas.style.cursor = "pointer";
                // ç”»åŠé€æ˜é¢„è§ˆæ£‹å­
                const x = PADDING + col * CELL_SIZE;
                const y = PADDING + row * CELL_SIZE;
                const radius = CELL_SIZE * 0.43;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fillStyle = myColor === 1 ? "rgba(0,0,0,0.3)" : "rgba(255,255,255,0.3)";
                ctx.fill();
            } else {
                canvas.style.cursor = "default";
            }
        });

        canvas.addEventListener("mouseleave", () => {
            canvas.style.cursor = "default";
            drawBoard();
        });

        // ============================================================
        // UI æ›´æ–°
        // ============================================================
        function updateStatus() {
            const statusEl = document.getElementById("status");
            statusEl.className = "";

            if (winner !== 0) {
                if (winner === -1) {
                    statusEl.textContent = "å¹³å±€ï¼";
                } else {
                    const winnerName = winner === 1 ? "é»‘æ–¹" : "ç™½æ–¹";
                    const isMe = winner === myColor;
                    statusEl.textContent = isMe ? `ğŸ‰ ä½ èµ¢äº†ï¼ï¼ˆ${winnerName}èƒœï¼‰` : `${winnerName}è·èƒœï¼`;
                }
                statusEl.classList.add("winner");

            } else if (!gameStarted) {
                statusEl.textContent = "â³ ç­‰å¾…å¯¹æ‰‹åŠ å…¥...";
                statusEl.classList.add("waiting");

            } else {
                const turnName = currentTurn === 1 ? "é»‘æ–¹" : "ç™½æ–¹";
                const isMyTurn = currentTurn === myColor;
                if (myColor === 0) {
                    statusEl.textContent = `è§‚æˆ˜ä¸­ â€” å½“å‰ ${turnName} è½å­`;
                } else {
                    statusEl.textContent = isMyTurn ? `è½®åˆ°ä½ äº†ï¼ˆ${turnName}ï¼‰` : `ç­‰å¾…å¯¹æ‰‹è½å­...ï¼ˆ${turnName}å›åˆï¼‰`;
                }
                statusEl.classList.add(currentTurn === 1 ? "turn-black" : "turn-white");
            }
        }

        function updateRoleDisplay() {
            const roleEl = document.getElementById("roleInfo");
            roleEl.className = "info-item";

            if (myRole === "black") {
                roleEl.textContent = "âš« ä½ æ˜¯é»‘æ–¹ï¼ˆå…ˆæ‰‹ï¼‰";
                roleEl.classList.add("role-black");
            } else if (myRole === "white") {
                roleEl.textContent = "âšª ä½ æ˜¯ç™½æ–¹ï¼ˆåæ‰‹ï¼‰";
                roleEl.classList.add("role-white");
            } else if (myRole === "spectator") {
                roleEl.textContent = "ğŸ‘ è§‚æˆ˜æ¨¡å¼";
                roleEl.classList.add("role-spectator");
            }
        }

        function setConnection(state) {
            const dot = document.getElementById("connDot");
            const text = document.getElementById("connText");
            dot.className = "connection-dot " + state;
            const labels = { connected: "å·²è¿æ¥", disconnected: "å·²æ–­å¼€", connecting: "è¿æ¥ä¸­" };
            text.textContent = labels[state] || state;
        }

        // ============================================================
        // WebSocket è¿æ¥
        // ============================================================
        function connect() {
            // è‡ªåŠ¨æ£€æµ‹ ws æˆ– wss
            const protocol = location.protocol === "https:" ? "wss:" : "ws:";
            const url = `${protocol}//${location.host}/ws`;

            setConnection("connecting");
            ws = new WebSocket(url);

            ws.onopen = () => {
                setConnection("connected");
                reconnectDelay = 1000; // é‡ç½®é‡è¿å»¶è¿Ÿ
                console.log("WebSocket å·²è¿æ¥");
            };

            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleMessage(data);
            };

            ws.onclose = () => {
                setConnection("disconnected");
                console.log("WebSocket æ–­å¼€ï¼Œå‡†å¤‡é‡è¿...");
                scheduleReconnect();
            };

            ws.onerror = (err) => {
                console.error("WebSocket é”™è¯¯:", err);
                ws.close();
            };
        }

        function scheduleReconnect() {
            if (reconnectTimer) clearTimeout(reconnectTimer);
            reconnectTimer = setTimeout(() => {
                console.log(`å°è¯•é‡è¿ï¼ˆå»¶è¿Ÿ ${reconnectDelay}msï¼‰...`);
                connect();
                // æŒ‡æ•°é€€é¿ï¼Œæœ€é•¿ 10 ç§’
                reconnectDelay = Math.min(reconnectDelay * 1.5, 10000);
            }, reconnectDelay);
        }

        function handleMessage(data) {
            switch (data.type) {
                case "role_assigned":
                    myColor = data.color;
                    myRole = data.role;
                    updateRoleDisplay();
                    break;

                case "sync_state":
                    board = data.board;
                    currentTurn = data.current_turn;
                    winner = data.winner;
                    gameStarted = data.game_started;
                    // æ‰¾åˆ°æœ€åä¸€æ­¥
                    if (data.move_history && data.move_history.length > 0) {
                        const last = data.move_history[data.move_history.length - 1];
                        lastMove = { row: last[0], col: last[1], color: last[2] };
                    } else {
                        lastMove = null;
                    }
                    drawBoard();
                    updateStatus();
                    break;

                case "game_start":
                    gameStarted = true;
                    updateStatus();
                    break;

                case "move":
                    board[data.row][data.col] = data.color;
                    currentTurn = data.current_turn;
                    winner = data.winner;
                    lastMove = { row: data.row, col: data.col, color: data.color };
                    drawBoard();
                    updateStatus();
                    break;

                case "reset":
                    board = Array.from({length: 15}, () => Array(15).fill(0));
                    currentTurn = 1;
                    winner = 0;
                    lastMove = null;
                    gameStarted = data.game_started;
                    drawBoard();
                    updateStatus();
                    break;

                case "player_left":
                    gameStarted = false;
                    updateStatus();
                    break;

                case "online_count":
                    document.getElementById("onlineInfo").textContent =
                        `ç©å®¶: ${data.players}/2 | è§‚ä¼—: ${data.spectators}`;
                    break;

                case "error":
                    console.warn("æœåŠ¡å™¨é”™è¯¯:", data.message);
                    break;
            }
        }

        function requestReset() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: "reset" }));
            }
        }

        // ============================================================
        // å“åº”å¼ Canvas
        // ============================================================
        function resizeCanvas() {
            const maxWidth = Math.min(window.innerWidth - 40, 600);
            canvas.style.width = maxWidth + "px";
            canvas.style.height = maxWidth + "px";
        }

        window.addEventListener("resize", resizeCanvas);
        resizeCanvas();

        // ============================================================
        // å¯åŠ¨
        // ============================================================
        drawBoard();
        connect();
    </script>
</body>
</html>
